import neurostim.light_propagation_models as light_propagation_models
import itertools
import random

class Stimulator:
    def __init__(self, diameter_um: float, NA: float):
        """
        Optical fiber light model implemented according to 
        Foutz et al. 2012, Aravnis et al. 2007.

        Args:
            diameter_um (float): Diameter of the optical fiber in micrometers.
            NA (float): Numerical aperture of the optical fiber.
        """
        self.diameter_um = diameter_um
        self.NA = NA
        self.light_propagation = getattr(light_propagation_models, "fiber_Foutz2012")
        self.modelname = "foutz_et_al2012"

    def calculate_Tx_at_pos(self, pos_xyz_um: list, stim_xyz_um: list) -> float:
        """
        Compute light loss at position pos_xyz_um considering stimulator at stim_xyz_um.

        Args:
            pos_xyz_um (list): (x, y, z) position of the target in micrometers.
            stim_xyz_um (list): (x, y, z) position of the stimulator in micrometers.

        Returns:
            float: Light transmission factor [1/cm^2].
        """
        if not (isinstance(pos_xyz_um, (list,tuple)) and isinstance(stim_xyz_um, (list,tuple))):
            raise ValueError("pos_xyz_um and stim_xyz_um must be lists or tuples of [x, y, z] coordinates in micrometers.")
        if len(pos_xyz_um) != 3 or len(stim_xyz_um) != 3:
            raise ValueError("pos_xyz_um and stim_xyz_um must each have three elements: [x, y, z].")

        # Calculate relative position
        relative_pos_xyz_um = [target - source for target, source in zip(pos_xyz_um, stim_xyz_um)]
        
        # Compute light transmission using the propagation model
        Tx = self.light_propagation(*relative_pos_xyz_um, self.diameter_um, NA=self.NA)
        
        return Tx

class MultiStimulator:
    def __init__(self, stimulators: list):
        """
        Initialize the MultiStimulator with a list of stimulator configurations.

        Args:
            stimulators (list): A list of dictionaries, each containing the parameters for a Stimulator.
                                Each dictionary should have the keys 'diameter_um', 'NA', 'position', and 'intensity_scale'.
                                Example:
                                [
                                    {'diameter_um': 200.0, 'NA': 0.37, 'position': [0, 0, 0], 'intensity_scale': 1.0},
                                    {'diameter_um': 300.0, 'NA': 0.45, 'position': [100, 100, 0], 'intensity_scale': 0.8}
                                ]
        """
        self.stimulators = []
        for stim_config in stimulators:
            stim = Stimulator(stim_config['diameter_um'], stim_config['NA'])
            stim.position = stim_config['position']
            stim.intensity_scale = stim_config['intensity_scale']
            self.stimulators.append(stim)

    def calculate_Tx_at_pos(self, pos_xyz_um: list, stim_xyz_um: list) -> float:
        """
        Calculate the combined light intensity at a given position in space generated by all stimulators.

        Args:
            pos_xyz_um (list): (x, y, z) position of the target in micrometers.

        Returns:
            float: Combined light transmission factor [1/cm^2] at the target position.
        """
        total_intensity = 0.0
        for stim in self.stimulators:
            # shift stim position by given stim_xyz_um:
            stim_position = [xyz + xyz_shift for xyz, xyz_shift in zip(
                list(stim.position), 
                list(stim_xyz_um)
                )
            ]
            intensity = stim.calculate_Tx_at_pos(pos_xyz_um, stim_position)
            total_intensity += intensity * stim.intensity_scale
        return total_intensity

def generate_occupied_positions(N, grid_width, grid_spacing):
    """
    Generate N random occupied positions on a quadratic grid at z=0 with a specific distance between grid points.

    Args:
        N (int): Number of stimulators.
        grid_width (int): Width of the grid (number of points along one dimension).
        grid_spacing (float): Distance between grid points in micrometers.

    Returns:
        list: A list of positions in the format [x, y, 0].
    """
    all_positions = list(itertools.product(range(grid_width), range(grid_width)))
    occupied_positions = random.sample(all_positions, N)
    occupied_positions = [[x * grid_spacing, y * grid_spacing, 0] for x, y in occupied_positions]
    # substract abs gird width to center grid over [0,0,0]
    abs_grid_width = (grid_width-1) * grid_spacing
    occupied_positions = [[x-abs_grid_width/2, y-abs_grid_width/2, z] for x,y,z in occupied_positions]
    return occupied_positions
